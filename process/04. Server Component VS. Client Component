1. Server Component
: 
- UI가 서버사이드에서 렌더링됨.
- 서버사이드에서 데이터를 fetching함( 렌더링에 필요한 데이터에 가까운 서버사이드에서 페칭하므로 에서 퍼포먼스 향상). => 요청시간 단축
- 토큰, API Key와 같은 민감한 데이터와 로직을 클라이언트에 노출하지 않고 서버에서 처리하므로 CSR에 비해 보안에 강함.
- 데이터가 캐쉬됨(선택적). 서버에서 렌더링하므로 결과가 캐쉬되어 많은 연속적인 요청이나 여러 유저들에게 사용될 수 있음.
    따라서 요청 시마다 데이터를 페칭하고 렌더링하는 과정이 생략되기 때문에 퍼포먼스가 향상됨. 
- 번들사이즈 축소: 서버 컴포넌트가 복잡한 라이브러리와 대규모 dependency에 대한 처리를 담당함. 클라이언트는 렌더링된 결과만 받기 때문에 클라이언트에서 다운 받아야 하는 번들사이즈가 축소되고 효율 향상됨.
- 초기 페이지 로딩과 FCP제공: 클라이언트에서 페이지를 페이지를 렌더링하기 위한 JS를 다운로드/파싱/실행하여 할 필요 없이 즉시 볼 수 있는 HTML을 서버사이드에서 생성하여 제공함.
- SEO에 강함(서버에서 미리 구조화 하여 내려주기 떄문에...)
- 서버 컴포넌트가 렌더링 작업을 덩어리로 쪼개서 클라이언트가 준비됐을 때 스트리밍해줌. 유저는 페이지 전체가 렌더링 되기를 기다릴 필요 없이, 페이지의 일부를 미리 볼 수 있음. 
 

 2. static rendering(Server side) vs. dynamic rendering(Client)
 
    2.1. static rendering(Server side): 
        '기본적'으로는 빌드 타임에 라우팅이 렌더/캐쉬되어 CDN에 푸쉬됨. 따라서 매 유저의 매 요청 시마다 렌더링 할 필요가 없음.
        기본적으로 app 디렉토리의 모든 컴포넌트는 서버 컴포넌트임.
 
    2.2. dynamic rendering(Client):  
        매 유저의 매 요청 시마다 라우팅이 렌더링됨.
        이벤트 리스너를 추가하거나 DOM을 변화시키거나, 상태 사용 또는 useState(),useEffect, useReducer와 같은 생명주기 효과를 사용하려면 클라이언트 컴포넌트를 사용해야함.
        이런 함수들을 사용하는 커스텀 훅을 사용하는 컴포넌트도 마찬가지. 
        Broser-only API를 사용할 때도 마찬가지.
    

